#!/usr/bin/env bash

declare LOGGER_FACILITY='user'
declare LOGGER_TAG="${0##*/}"
declare -a LOGGER_OPTS_INFO=(
    -i -t "$LOGGER_TAG"
    -p "$LOGGER_FACILITY.debug"
)
declare -a LOGGER_OPTS_INFO=(
    -i -t "$LOGGER_TAG"
    -p "$LOGGER_FACILITY.info"
)
declare -a LOGGER_OPTS_ERR=(
    -i -t "$LOGGER_TAG"
    -p "$LOGGER_FACILITY.err"
)

# Usage: log [LEVEL] [MSG]
# LEVEL:
#   d  debug             Only print these when $debug is set to true
#   e  error             Print an error message
#   i  info              Print an informative message
#   *                    Same as info
function log() {
    local level="$1"
    local msg="$2"

    case "$level" in
    d | debug)
        logger "${LOGGER_OPTS_DEBUG[@]}" "$msg"
        ;;
    e | error)
        logger "${LOGGER_OPTS_ERR[@]}" "$msg"
        ;;
    *)
        logger "${LOGGER_OPTS_INFO[@]}" "$msg"
        ;;
    esac
}

function handle_sigterm() {
    log i "SIGTERM received, stopping"
    done='true'
}

function handle_sigint() {
    log i "SIGINT received, stopping"
    done='true'
}

function usage() {
    log i "$0 [OPTIONS...]"
    log i ""
    log i "Options:"
    log i "  -v    Verbose"
    log i "  -n    NetworkManager connection name"
    log i "  -f    Maximum number of failed pings to consider network down"
    log i "  -t    Timeout to reset number of failed pings to 0"
    log i "  -i    Interval in seconds to wait between each ping"
    log i "  -D    IP address to ping"
    log i "  -W    Ping timeout (ping -W option)"
    log i "  -R    Do not reconnect if connection is lost"
    log i "  -h    Show this message and exit"
}

trap handle_sigterm SIGTERM
trap handle_sigint SIGINT

declare net_name=""

declare max_fails=3
declare fail_timeout=3
declare interval=1
declare reconnect='true'

declare gw=""
declare ping_timeout="0.1"

while getopts ":hRn:f:t:i:g:W:" arg; do
    case "$arg" in
    n) net_name="$OPTARG" ;;
    f) max_fails="${OPTARG:-3}" ;;
    t) fail_timeout="${OPTARG:-3}" ;;
    i) interval="${OPTARG:-1}" ;;
    g) gw="${OPTARG}" ;;
    W) ping_timeout="${OPTARG:-0.1}" ;;
    R) reconnect='false' ;;
    h)
        usage
        exit 0
        ;;
    *)
        usage
        exit 1
        ;;
    esac
done

if [ "$reconnect" == 'true' ] && [ -z "$net_name" ]; then
    use_nm='false'
    log i "NetworkManager connection name is missing. Will use arp ping to reconnect"
fi

if [ -z "$gw" ]; then
    log e "Gateway is required"
    exit 1
fi

declare -a ping_opts=(
    '-W' "$ping_timeout"
    '-c' '1'
    "$gw"
)

log i "$LOGGER_TAG is started"
log i "net_name = $net_name"
log i "max_fails = $max_fails"
log i "fail_timeout = $fail_timeout"
log i "gateway = $gw"
log i "interval = $interval"
log i "ping_timeout = $ping_timeout"
log i "reconnect = $reconnect"

declare -g timer=0
declare -g fail_count=0
declare -g done='false'

while [ "$done" = 'false' ]; do
    log d "ping ${ping_opts[*]}"
    ping "${ping_opts[@]}" 1>/dev/null 2>&1 && {
        sleep "$interval"
        continue
    }

    fail_count=$((fail_count + 1))
    if [ "$fail_count" -ge "$max_fails" ]; then
        log e "Connection lost to $gw"

        if [ "$reconnect" = 'true' ]; then
            if [ "$use_nm" = 'true' ]; then
                log i "Trying to reconnect using nmcli"

                _out="$(nmcli c down "$net_name" 2>&1)"
                log i "nmcli c down: '$_out'"

                _out="$(nmcli c up "$net_name")"
                log i "nmcli c up: '$_out'"
            else
                log i "Trying to reconnect using arping to ping gateway"

                _out="$(arping -qc1 "$gw")"
                log i "arping -qc1 $gw: '$_out'"
            fi
        fi

        fail_count=0
    fi

    sleep "$interval"
    timer=$((timer + 1))
    if [ "$timer" -ge "$fail_timeout" ]; then
        fail_count=0
        timer=0
    fi
done
